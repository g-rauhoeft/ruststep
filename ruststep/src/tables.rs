//! Traits for espr-generated structures
//!
//! Examples
//! ---------
//!
//! Convert STEP data section into tables.
//!
//! ```
//! use ruststep::{parser::exchange, ap000::Ap000};
//! use nom::Finish;
//!
//! let (_, data_section) = exchange::data_section(
//!     r#"
//!     DATA;
//!       #2 = A(1.0, 2.0);
//!       #4 = B(2.0, A((4.0, 5.0)));
//!       #5 = B(2.0, #2);
//!     ENDSEC;
//!     "#
//!     .trim(),
//! )
//! .finish()
//! .unwrap();
//!
//! // Entity reference `#2` is not resolved at this point.
//! let table = Ap000::from_section(&data_section).unwrap();
//!
//! for a in table.a_iter() { // Iterate over top-level `A`s.
//!   dbg!(a);                // Do not iterate over the inline struct `A((4.0, 5.0))` in `#4`
//! }
//!
//! for b in table.b_iter() { // Because reference lookup is done while iteration,
//!   dbg!(b);                // `b` may be `Result::Err` if reference is undefined.
//! }
//!
//! for c in table.c_iter() { // No iteration occurs since `C` is not defined
//!   dbg!(c);
//! }
//! ```
//!
//! STEP exchange structure AST is converted into Rust structure in two steps:
//!
//! 1.  Parse AST to `*Holder` private struct without resolving entity references,
//!    e.g. `B(2.0, #2)` will be converted into a Rust struct
//!         `BHolder { z: 2.0, a: RValue::Entity(2)}`.
//!     - `Ap000::from_section` as above example
//! 2. Resolve reference `#2` to `A(1.0, 2.0)`.
//!    This will be done while the iteration.
//!     - `a_iter()` as above example
//!

use std::collections::HashMap;

#[cfg(doc)]
use crate::{ap000, place_holder::*};

/// Trait for resolving a reference through entity id
///
/// STEP input is once deserialized into a holder struct, e.g. [ap000::AHolder],
/// which contains [PlaceHolder] for skipping table lookup.
/// Entity table represented by the trait [EntityTable] will be looked up to resolve the reference
/// at [PlaceHolder::into_owned], and this trait is for supporting this method.
///
/// Holder structs, e.g. [ap000::AHolder] will be generated by espr,
/// and implementation of this trait will be also generated at the same time.
///
pub trait Holder: Clone + 'static {
    type Owned;
    type Table;
    fn into_owned(self, table: &Self::Table) -> Result<Self::Owned, crate::error::Error>;
    fn name() -> &'static str;
    fn attr_len() -> usize;
}

/// Trait for tables which pulls an entity (`T`) from an entity id (`u64`)
pub trait EntityTable<T: Holder<Table = Self>> {
    /// Get owned entity from table
    fn get_owned(&self, entity_id: u64) -> Result<T::Owned, crate::error::Error>;

    /// Get owned entities as an iterator
    fn owned_iter<'table>(
        &'table self,
    ) -> Box<dyn Iterator<Item = Result<T::Owned, crate::error::Error>> + 'table>;
}

pub(crate) fn get_owned<T, Table>(
    table: &Table,
    map: &HashMap<u64, T>,
    entity_id: u64,
) -> Result<T::Owned, crate::error::Error>
where
    T: Holder<Table = Table>,
    Table: EntityTable<T>,
{
    match map.get(&entity_id) {
        Some(holder) => holder.clone().into_owned(table),
        None => Err(crate::error::Error::UnknownEntity(entity_id)),
    }
}

pub(crate) fn owned_iter<'table, T, Table>(
    table: &'table Table,
    map: &'table HashMap<u64, T>,
) -> Box<dyn Iterator<Item = Result<T::Owned, crate::error::Error>> + 'table>
where
    T: Holder<Table = Table>,
    Table: EntityTable<T>,
{
    Box::new(
        map.values()
            .cloned()
            .map(move |value| value.into_owned(table)),
    )
}
